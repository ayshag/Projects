"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var _ = require("lodash");
var utils_1 = require("./utils");
function buildResolver() {
    var resolver = function (source, args, context, info) {
        var src = source[info.fieldName] ? source[info.fieldName] : source.$data[info.fieldName];
        return src.$data ? src.$data : src;
    };
    return resolver;
}
function buildFieldType(fieldName, fieldValues, fieldMeta, fieldTypes) {
    var existed = fieldTypes[fieldName];
    if (!existed) {
        var isList = _.isArray(fieldValues.$data);
        existed = {
            isList: isList,
            type: isList
                ? parseGraphQLArray(fieldName, fieldValues, fieldTypes)
                : parseGraphQLObject(fieldName, fieldValues, fieldTypes),
            nullable: false,
        };
        fieldTypes[fieldName] = existed;
    }
    if (fieldMeta.description) {
        existed.type.description = fieldMeta.description;
    }
    var type = existed.isList ? new graphql_1.GraphQLList(existed.type) : existed.type;
    return existed.nullable ? type : new graphql_1.GraphQLNonNull(type);
}
function parseModelData(data, meta, types) {
    var fields = {};
    _.each(data, function (val, key) {
        if (key === meta.idField) {
            fields[key] = {
                type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLID),
                resolve: buildResolver(),
            };
        }
        else {
            var scalarType = utils_1.getScalarType(val);
            if (scalarType) {
                fields[key] = {
                    type: new graphql_1.GraphQLNonNull(scalarType),
                    resolve: buildResolver(),
                };
            }
            else {
                fields[key] = {
                    type: buildFieldType(key, val, val.$meta, types),
                    resolve: buildResolver(),
                };
            }
        }
    });
    return fields;
}
function parseGraphQLArray(modelKey, model, types) {
    var fields = {};
    _.each(model.$data, function (modelData) {
        fields = __assign({}, fields, parseModelData(modelData, model.$meta, types));
    });
    var type = new graphql_1.GraphQLObjectType({
        name: modelKey,
        fields: function () { return fields; },
    });
    return type;
}
exports.parseGraphQLArray = parseGraphQLArray;
function parseGraphQLObject(modelKey, model, types) {
    var fields = parseModelData(model.$data, model.$meta, types);
    var type = new graphql_1.GraphQLObjectType({
        name: modelKey,
        fields: function () { return fields; },
    });
    return type;
}
exports.parseGraphQLObject = parseGraphQLObject;
function parseRootData(rootData, raw) {
    var allFieldTypesDict = {};
    var rootFields = {};
    _.each(rootData, function (model, modelKey) {
        parseGraphQLObject(modelKey, model, allFieldTypesDict);
    });
    _.each(raw, function (val, key) {
        rootFields[key] = {
            type: buildFieldType(key, val, rootData.root.$meta, allFieldTypesDict),
            resolve: buildResolver(),
        };
    });
    var query = new graphql_1.GraphQLObjectType({
        name: 'RootType',
        fields: function () { return rootFields; },
    });
    var schema = new graphql_1.GraphQLSchema({
        types: _.entries(allFieldTypesDict).map(function (_a) {
            var key = _a[0], val = _a[1];
            return val.type;
        }),
        query: query,
    });
    return schema;
}
exports.parseRootData = parseRootData;
//# sourceMappingURL=graphql.parser.js.map